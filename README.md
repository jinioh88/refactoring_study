## ch1 리팩터링: 첫 번째 예시
- 설계가 나쁜 시스템은 수정하기 어렵다. 
- 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다. 
  ```
  function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer}\n';
    const format = new Intl.NumberFormat("en-US", 
                    { style: "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for(let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = 0;

        switch(play.type) {
            case "tragedy":
                thisAmount = 40000;
                if(perf.audience > 30) {
                    thisAmount += 1000 *(perf.audience - 30);
                }
                break;
            case "comedy":
                thisAmount = 30000;
                if(perf.audience > 20) {
                    thisAmount += 10000 + 500 *(perf.audience - 20);
                }
                thisAmount += 300 * perf.audience;
                break;W
            default:
                throw new Error('알 수 없는 장르: ${play.type}');
        }

        volumeCredits += Math.max(perf.audience - 30, 0);
        if("comedy" === play.type) {
            volumeCredits += Math.floor(perf.audience / 5);
        }

        result += ' ${play.name}}: ${format(thisAmount/100)} (${perf.audience}석)\n';
        totalAmount + thisAmount;
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumCredits}점\n';
    return result;   
  }
  ```
  - 위 함수는 연극 장르와 공연료 정책이 달라질 때마다 statemnet 함수를 수정해야 한다.
  - 만약 HTML로 출력하는 htemlStatement()를 만든다면 statement 코드를 그대로 복사한 후 모든 수정이 두 함수에 일관되게 반영되도록 보장해야 한다. 

3. 리팩터링의 첫 단계
- 첫 단계는 항상 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드를 마련해야 한다. 
  - 테스트는 반드시 자가진단하도록 만든다.

4. statement() 함수 쪼개기
- 긴 함수를 리팩터링 할 때는 먼저 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다. 
- 코드 조각을 별도 함수로 추출하는 방식으로 앞의 조각낸 부분을 반영한다. (함수추출하기)
- 리팩터링 후 항상 테스트하는 습관을 들이자. 조금씩 수정하여 매번 테스트하자. 
- 임시변수는 나중에 문제를 일으킬 수 잇어 제거하는 것이 좋다. 

8. 다형성을 활용해 계산 코드 재구성하기
- 조건부 로직을 명확한 구조로 보안하는 방법중 하나는 조건부 로직을 다형성으로 바꾸기다. 
- 이 리팩터링을 적용하려면 상속 계층부터 정의해야 한다. 

---
## CH2 리팩터링 원칙
1. 리팩터링 정의
- 명사로써의 리팩터링: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.
- 동사로써의 리팩터링: 수프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 직용해 소프트웨어를 재구성하다. 
- 리팩터링 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램 성능은 좋아질 수도, 나빠질 수도 있다. 

2. 두 개의 모자
- 소프트웨어를 개발할 때 목적이 '기능추가'냐, 아니면 '리팩터링'이냐의 구분을 두 개의 모자라고 켄트백이 비유했다.
- 기능 추가는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 
- 리팩토링할 때는 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 

3. 리팩터링하는 이유
- 리팩터링하면 소프트웨어 설계가 좋아진다.
  - 리팩터링하지 않으면 소프트웨어의 내부 설계가 썩기 쉽다. 
  - 설계가 나쁘면 코드가 길어지기 십상이다. 
  - 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있고, 이는 바람직한 설계의 핵심이다. 
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
  - 리팩터링은 코드가 더 잘 읽히게 도와준다. 코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다. 
- 리팩터링하면 버그를 쉽게 찾을 수 있다.
  - 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.
  - 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 수비게 찾을 수 있다. 

4. 언제 리팩터링해야 할까?
- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
  - 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 
  - 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다. 
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
  - 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 
  - 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. 
- 쓰레기 줍기 리팩터링
  - 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 메모를 해두고 하던 일을 끝내고 나서 처리하는 방식이다. 
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다. 
- 코드 리뷰에 리팩터링 활용하기
  - 리팩토링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데 도움된다. 
  - 좋은 방법은 작성자와 나란히 앉아 코드를 훑어가면서 리팩터링하는 것이다. 자연스럽게 짝 프로그래밍이 된다. 
- 리팩터링하지 말아야 할 때
  - 외부 api 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다. 
  - 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다. 


